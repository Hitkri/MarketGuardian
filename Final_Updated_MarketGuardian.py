import os
import logging
import time
import uuid
import sqlite3
import asyncio
import requests
import pandas as pd
import numpy as np
from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update, InputMediaPhoto
from telegram.ext import ApplicationBuilder, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from io import BytesIO
import ccxt
import mplfinance as mpf
import matplotlib.pyplot as plt

# === API KEYS ===
TELEGRAM_BOT_TOKEN = '7635928627:AAFiDfGdfZKoReNnGDXkjaDm4Q3qm4AH0t0'
ADMIN_ID = int(os.getenv('ADMIN_ID', '1407143951'))

# === LOGGING ===
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger('trading_assistant')

# === DATABASE ===
conn = sqlite3.connect('trading_bot.db', check_same_thread=False)
cursor = conn.cursor()
cursor.execute('CREATE TABLE IF NOT EXISTS tokens (token TEXT PRIMARY KEY, user_id INTEGER UNIQUE, username TEXT, activation_time REAL)')
cursor.execute('CREATE TABLE IF NOT EXISTS trades (id INTEGER PRIMARY KEY AUTOINCREMENT, timestamp REAL, user_id INTEGER, symbol TEXT, side TEXT, entry REAL, active INTEGER DEFAULT 1, profit REAL DEFAULT 0.0)')
conn.commit()

# === STATE ===
active_positions = {}

# === TELEGRAM ===
scheduler = AsyncIOScheduler()
scheduler.start()

exchange = ccxt.binance()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text('–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ù–∞–ø–∏—à–∏ /menu')

async def menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pairs = ['TONUSDT', 'BTCUSDT', 'ETHUSDT', 'XRPUSDT', 'BNBUSDT', 'SOLUSDT']
    buttons = [[InlineKeyboardButton(p, callback_data=f'select_{p}')] for p in pairs]
    buttons.append([InlineKeyboardButton('üìÖ –û—Ç—á—ë—Ç –ø–æ —Å–¥–µ–ª–∫–∞–º', callback_data='report')])
    markup = InlineKeyboardMarkup(buttons)
    await update.message.reply_text('–í—ã–±–µ—Ä–∏ –ø–∞—Ä—É –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è:', reply_markup=markup)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    data = update.callback_query.data
    uid = update.effective_chat.id

    if data.startswith('select_'):
        symbol = data.replace('select_', '')
        await context.bot.send_message(uid, f'üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é {symbol}...')
        entry_price = await fetch_price(symbol)
        active_positions[uid] = {'symbol': symbol, 'entry': entry_price, 'side': 'LONG'}
        cursor.execute('INSERT INTO trades (timestamp, user_id, symbol, side, entry) VALUES (?, ?, ?, ?, ?)',
                       (time.time(), uid, symbol, 'LONG', entry_price))
        conn.commit()

        chart = await generate_chart(symbol, entry_price)
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ –í—Ö–æ–¥", callback_data='enter')],
            [InlineKeyboardButton("‚ùå –ó–∞–∫—Ä—ã—Ç—å —Å–¥–µ–ª–∫—É", callback_data='close')]
        ])
        await context.bot.send_photo(chat_id=uid, photo=chart,
            caption=f'üìà –í—Ö–æ–¥ –≤ –ø–æ–∑–∏—Ü–∏—é {symbol} (LONG) –ø–æ {entry_price}\nüéØ Take Profit: {round(entry_price * 1.01, 4)}\nüõë Stop Loss: {round(entry_price * 0.99, 4)}',
            reply_markup=kb)
        await update.callback_query.answer()

    elif data == 'enter':
        trigger = IntervalTrigger(seconds=30)
        scheduler.add_job(monitor_price, trigger, args=[context, uid], id=f'monitor_{uid}', replace_existing=True)
        await context.bot.send_message(uid, 'üü¢ –°–¥–µ–ª–∫–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞. –°–ª–µ–∂—É –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ–º.')
        await update.callback_query.answer()

    elif data == 'close':
        try:
            scheduler.remove_job(f'monitor_{uid}')
        except:
            pass
        cursor.execute('SELECT id FROM trades WHERE user_id=? AND active=1 ORDER BY timestamp DESC LIMIT 1', (uid,))
        trade = cursor.fetchone()
        if trade:
            cursor.execute('UPDATE trades SET active=0 WHERE id=?', (trade[0],))
            conn.commit()
        active_positions.pop(uid, None)
        await context.bot.send_message(uid, 'üíº –°–¥–µ–ª–∫–∞ –∑–∞–∫—Ä—ã—Ç–∞. –ù–∞–ø–∏—à–∏ +10 –∏–ª–∏ -5 ‚Äî —Å–∫–æ–ª—å–∫–æ –∑–∞—Ä–∞–±–æ—Ç–∞–ª/–ø–æ—Ç–µ—Ä—è–ª?')
        await update.callback_query.answer()

    elif data == 'report':
        report = generate_report(uid)
        await context.bot.send_message(uid, report)
        await update.callback_query.answer()

async def monitor_price(context, uid):
    if uid not in active_positions:
        return
    pos = active_positions[uid]
    symbol = pos['symbol']
    entry = pos['entry']
    now_price = await fetch_price(symbol)
    delta = now_price - entry
    danger_zone = round(entry * 0.985, 4)
    tp = round(entry * 1.01, 4)
    sl = round(entry * 0.99, 4)

    rsi, macd_signal = await fetch_indicators(symbol)

    status = f"üìä {symbol} ({pos['side']})\n–í—Ö–æ–¥: {entry} | –°–µ–π—á–∞—Å: {now_price}\n"
    if now_price <= sl:
        status += "‚ùó –¶–µ–Ω–∞ –¥–æ—Å—Ç–∏–≥–ª–∞ Stop Loss. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é."
    elif now_price >= tp:
        status += "‚úÖ –î–æ—Å—Ç–∏–≥–Ω—É—Ç Take Profit. –ó–∞—Ñ–∏–∫—Å–∏—Ä—É–π—Ç–µ –ø—Ä–∏–±—ã–ª—å."
    elif now_price < danger_zone:
        status += f"‚ö†Ô∏è –¶–µ–Ω–∞ –æ–ø—É—Å—Ç–∏–ª–∞—Å—å –Ω–∏–∂–µ {danger_zone}. –í–æ–∑–º–æ–∂–µ–Ω –ø—Ä–æ–±–æ–π –≤–Ω–∏–∑ ‚Äî –ø–æ–¥—É–º–∞–π—Ç–µ –æ –≤—ã—Ö–æ–¥–µ."
    elif abs(delta) < 0.002:
        status += "‚è≥ –†—ã–Ω–æ–∫ –≤ –±–æ–∫–æ–≤–∏–∫–µ. –ú–æ–∂–Ω–æ –∂–¥–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."
    else:
        status += f"üîÑ –¶–µ–Ω–∞ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –Ω–æ—Ä–º—ã.\n–ï—Å–ª–∏ —Ü–µ–Ω–∞ –ø—Ä–æ–±—å—ë—Ç {tp}, –≤–æ–∑–º–æ–∂–µ–Ω —Ä–æ—Å—Ç. –ï—Å–ª–∏ —É–ø–∞–¥—ë—Ç –Ω–∏–∂–µ {sl}, –≤–æ–∑–º–æ–∂–µ–Ω —Ä–∞–∑–≤–æ—Ä–æ—Ç –≤–Ω–∏–∑."

    status += f"\nüìà RSI: {rsi:.2f} | MACD —Å–∏–≥–Ω–∞–ª: {'‚Üë' if macd_signal else '‚Üì'}"
    await context.bot.send_message(uid, status)

async def fetch_price(symbol):
    try:
        ticker = exchange.fetch_ticker(symbol)
        return round(ticker['last'], 4)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã: {e}")
        return round(3.25 + np.random.uniform(-0.03, 0.03), 4)

async def fetch_indicators(symbol):
    try:
        ohlcv = exchange.fetch_ohlcv(symbol, '5m')[-50:]
        df = pd.DataFrame(ohlcv, columns=['Timestamp', 'Open', 'High', 'Low', 'Close', 'Volume'])
        df['RSI'] = compute_rsi(df['Close'], 14)
        macd_line = df['Close'].ewm(span=12).mean() - df['Close'].ewm(span=26).mean()
        signal_line = macd_line.ewm(span=9).mean()
        macd_signal = macd_line.iloc[-1] > signal_line.iloc[-1]
        return df['RSI'].iloc[-1], macd_signal
    except:
        return 50, False

def compute_rsi(series, period):
    delta = series.diff()
    gain = delta.where(delta > 0, 0)
    loss = -delta.where(delta < 0, 0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

async def generate_chart(symbol, entry_price):
    try:
        ohlcv = exchange.fetch_ohlcv(symbol, '5m')[-30:]
        df = pd.DataFrame(ohlcv, columns=['Timestamp', 'Open', 'High', 'Low', 'Close', 'Volume'])
        df['Date'] = pd.to_datetime(df['Timestamp'], unit='ms')
        df.set_index('Date', inplace=True)

        support = df['Low'].rolling(window=10).min().iloc[-1]
        resistance = df['High'].rolling(window=10).max().iloc[-1]

        apdict = [
            mpf.make_addplot(df['Close'].rolling(5).mean(), color='orange'),
            mpf.make_addplot([entry_price] * len(df), color='green', width=0.75, linestyle='--'),
            mpf.make_addplot([support] * len(df), color='red', linestyle=':'),
            mpf.make_addplot([resistance] * len(df), color='blue', linestyle=':')
        ]
        fig, axlist = mpf.plot(df, type='candle', style='charles', returnfig=True, volume=False, addplot=apdict)
        buf = BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        return buf
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≥—Ä–∞—Ñ–∏–∫–∞: {e}")
        return None

def generate_report(uid):
    cursor.execute('SELECT timestamp, profit FROM trades WHERE user_id=? AND profit != 0', (uid,))
    rows = cursor.fetchall()
    if not rows:
        return '‚õîÔ∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–¥–µ–ª–∫–∞–º.'

    from collections import defaultdict
    day_map = defaultdict(list)
    for t, p in rows:
        d = datetime.fromtimestamp(t).day
        day_map[d].append(p)

    text = 'üìÖ –û—Ç—á—ë—Ç –ø–æ —Å–¥–µ–ª–∫–∞–º:\n'
    monthly_total = 0
    for day in sorted(day_map):
        total = sum(day_map[day])
        monthly_total += total
        count = len(day_map[day])
        text += f'‚Ä¢ {day} —á–∏—Å–ª–æ: {total:+.2f} USD ({count} —Å–¥–µ–ª–æ–∫)\n'
    text += f'üìà –í—Å–µ–≥–æ –∑–∞ –º–µ—Å—è—Ü: {monthly_total:+.2f} USD'
    return text

async def profit_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_chat.id
    msg = update.message.text.strip().replace(',', '.')
    if msg.startswith('+') or msg.startswith('-') or msg.startswith('0'):
        try:
            profit = float(msg)
            cursor.execute('SELECT id FROM trades WHERE user_id=? AND active=0 ORDER BY timestamp DESC LIMIT 1', (uid,))
            trade = cursor.fetchone()
            if trade:
                cursor.execute('UPDATE trades SET profit=? WHERE id=?', (profit, trade[0]))
                conn.commit()
                await update.message.reply_text(f'üíæ –ó–∞–ø–∏—Å–∞–Ω–æ: {profit:+.2f} USD')
            else:
                await update.message.reply_text('‚ùå –°–¥–µ–ª–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.')
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –ø—Ä–∏–±—ã–ª–∏: {e}")
            await update.message.reply_text('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤–≤–æ–¥–µ –ø—Ä–∏–±—ã–ª–∏/—É–±—ã—Ç–∫–∞.')
    else:
        await update.message.reply_text('‚ö†Ô∏è –í–≤–µ–¥–∏ +10 –∏–ª–∏ -5 –¥–ª—è –∑–∞–ø–∏—Å–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.')

async def generate_token(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_ID:
        return await update.message.reply_text('Forbidden')
    token = str(uuid.uuid4())
    cursor.execute('INSERT INTO tokens(token) VALUES(?)', (token,))
    conn.commit()
    await update.message.reply_text(f'Token: {token}')

def main():
    app = ApplicationBuilder().token(TELEGRAM_BOT_TOKEN).build()
    app.add_handler(CommandHandler('start', start))
    app.add_handler(CommandHandler('menu', menu))
    app.add_handler(CommandHandler('generate_token', generate_token))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, profit_input))
    app.run_polling()

if __name__ == '__main__':
    main()
